// Generated by IcedCoffeeScript 1.3.3g
(function() {
  var Server, dns, iced, __iced_k, __iced_k_noop,
    __slice = [].slice;

  iced = require('iced-coffee-script').iced;
  __iced_k = __iced_k_noop = function() {};

  dns = require('native-dns');

  exports.Server = Server = (function() {

    function Server(port) {
      this.port = port;
      this.port = 53;
      this.server = dns.createServer();
      this.tab = {};
    }

    Server.prototype.setHooks = function() {
      var _this = this;
      this.server.on('request', (function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _this.request.apply(_this, args);
      }));
      this.server.on('error', (function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _this.error.apply(_this, args);
      }));
      this.server.on('socketError', function(err) {
        return console.log("[E] Error binding to port " + _this.port + ": " + err);
      });
      this.server.on('listening', function() {
        return console.log("[I] Listening on port " + _this.port);
      });
      return this.server.on('close', function() {
        return console.log("[E] Server closed..");
      });
    };

    Server.prototype.run = function() {
      this.setHooks();
      this.server.serve(this.port);
      return this.make_secure();
    };

    Server.prototype.error = function(err, buff, req, res) {
      return console.log("[E] Error: " + (JSON.stringify(err.stack)));
    };

    Server.prototype.resolve_locally = function(q) {
      var a, rec, ret;
      ret = null;
      if (((rec = this.tab[q.name]) != null) && ((a = rec[q.type]) != null)) {
        ret = {
          name: q.name,
          type: q.type,
          "class": q["class"],
          ttl: 30,
          address: a
        };
      }
      console.log("++ Local " + q.name + "/" + q.type + " -> " + (JSON.stringify(ret)));
      return ret;
    };

    Server.prototype.resolve_recursively = function(q, cb) {
      var name, res, rreq, type, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      name = q.name;
      type = dns.consts.QTYPE_TO_NAME[q.type];
      console.log("+ Recursive lookup for " + name + "/" + type);
      rreq = new dns.Request({
        question: new dns.Question({
          name: name,
          type: type
        }),
        server: {
          address: this.upstream,
          port: 53,
          type: 'udp'
        },
        timeout: 1000
      });
      res = [];
      rreq.on('timeout', function() {
        return console.log("[T] Timed out talking to " + _this.upstream);
      });
      rreq.on('message', function(err, answer) {
        var a, _i, _len, _ref, _results;
        if (answer.answer != null) {
          _ref = answer.answer;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            a = _ref[_i];
            console.log("++ Reply: " + name + "/" + type + " -> " + (JSON.stringify(a)));
            _results.push(res.push(a));
          }
          return _results;
        } else if (err) {
          return console.log("[E] Error in " + name + "/" + type + " -> " + err);
        }
      });
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/server.iced",
          funcname: "Server.resolve_recursively"
        });
        rreq.send();
        rreq.on('end', __iced_deferrals.defer({
          lineno: 83
        }));
        __iced_deferrals._fulfill();
      })(function() {
        console.log("+ Finish lookup for " + name + "/" + type);
        return cb(res);
      });
    };

    Server.prototype.parse_resolution = function(r) {
      var from, qtyp, to, typ, x;
      x = r.split(':');
      if (x.length !== 3) {
        throw "Resolution is malformed; need 3 parts: " + r;
      } else {
        from = x[0], typ = x[1], to = x[2];
        if (!((qtyp = dns.consts.NAME_TO_QTYPE[typ.toUpperCase()]) != null)) {
          throw "Unknown query type: " + typ;
        } else {
          if (this.tab[from] == null) this.tab[from] = {};
          this.tab[from][qtyp] = to;
          return console.log("[I] Resolving " + from + "/" + typ + " -> " + to);
        }
      }
    };

    Server.prototype.parse_args = function(argv) {
      var a, _i, _len, _ref;
      if (argv.p != null) this.port = argv.p;
      this.upstream = argv.u;
      _ref = argv._;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        this.parse_resolution(a);
      }
      this.uid = argv.U;
      this.gid = argv.G;
      return console.log("[I] Upstream server is: " + this.upstream);
    };

    Server.prototype.make_secure = function() {
      var u;
      u = process.getuid();
      if (u === 0) {
        if (this.gid) {
          console.log("[I] setgid to " + this.gid);
          process.setgid(this.gid);
        }
        if (this.uid) {
          console.log("[I] setuid to " + this.uid);
          return process.setuid(this.uid);
        }
      }
    };

    Server.prototype.resolve = function(q, cb) {
      var r, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      r = this.resolve_locally(q);
      (function(__iced_k) {
        if (r != null) {
          return __iced_k(r = [r]);
        } else {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/server.iced",
              funcname: "Server.resolve"
            });
            _this.resolve_recursively(q, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return r = arguments[0];
                };
              })(),
              lineno: 137
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        }
      })(function() {
        return cb(r);
      });
    };

    Server.prototype.request = function(req, res) {
      var q, r, results, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = req.question;
        _len = _ref.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            q = _ref[_i];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/server.iced",
                funcname: "Server.request"
              });
              _this.resolve(q, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return results = arguments[0];
                  };
                })(),
                lineno: 144
              }));
              __iced_deferrals._fulfill();
            })(function() {
              var _j, _len1;
              for (_j = 0, _len1 = results.length; _j < _len1; _j++) {
                r = results[_j];
                res.answer.push(r);
              }
              return _next();
            });
          }
        };
        _while(__iced_k);
      })(function() {
        return res.send();
      });
    };

    return Server;

  })();

  exports.run = function(argv) {
    var s;
    s = new Server;
    s.parse_args(argv);
    return s.run();
  };

}).call(this);
